library(plyr) #Bestand lezen ;, , ,\t
path <- file.choose() #path ophalen van file
gegevens <- ldply(path,function(x) #Gekozen bestand lezen
if(grepl(",",readLines(x,n=1))){read.csv(x,sep=",", header = TRUE, na.strings = c("", "NA"))}
else if(grepl(";",readLines(x,n=1))){read.csv(x,sep=";", header = TRUE, na.strings = c("", "NA"))}
else{read.csv(x,sep="\t", header = TRUE, na.strings = c("", "NA"))})
get_somError <- function(alle_Errors, nummer, pol, hydro, given){
#A, B en C worden random gekozen. Gebruik sample, omdat dit hele getallen geeft.
A <- sample(-50:50, 1)
B <- sample(-50:50, 1)
C <- sample(-50:50, 1)
#class predicted berekenen
Class_pred <- A * pol + B * hydro + C
#class predicted expondent
Class_pred_exp <- 1 / (1 + exp(-Class_pred))
#berekenen van error
Error <- (given - Class_pred_exp)^2
#Error en ClassPred toevoegen aan dataframe
gegevens$ClassPred <- Class_pred_exp
gegevens$Error <- Error
#Som berekenen error
sum_Error <- sum(gegevens$Error)
#Wortel berekenen van som error
wortel_sum_Error <- sqrt(sum_Error)
#Plot maken
pch.list <- as.numeric(gegevens$Given + 3)
plot(gegevens$Polarity, gegevens$Hydrophob. ,
pch=c(pch.list), xlab = "Polarity", ylab = "Hydrophob",
main = paste("Data plot: ", nummer),
sub = paste("A:", A, "   B:", B, "   C:", C, "   Sum error:", wortel_sum_Error, sep = " "),
xlim = c(0, 30), ylim = c(-30, 40))
#Lijn maken
x_line <- c(0:28)
y_line <- -c((C+A * x_line)/B)
lines(x_line,y_line)
abline(h=0,v=0)
#Alle waardes in een data.frame zetten
waardes <- c(nummer, A, B, C, wortel_sum_Error)
alle_Errors <- rbind(alle_Errors, waardes)
return(alle_Errors)
}
#De index ophalen waarin de gegevens staan die nodig zijn.
pol_index <- which(colnames(gegevens) == "Polarity")
pol <- gegevens[,pol_index]
hydro_index <- which(colnames(gegevens) == "Hydrophob.")
hydro <- gegevens[,hydro_index]
given_index <- which(colnames(gegevens) == "Given")
given <- gegevens[,given_index]
#Aanroepen van de functie hierboven.
alle_Errors <- data.frame()
nummer = 1
for(i in 1:1000){
alle_Errors <- get_somError(alle_Errors, nummer, pol, hydro, given)
nummer = nummer + 1
}
#kolomnamen maken
colnames(alle_Errors) <- c("nummer", "A", "B", "C", "Wortel sum error")
#barplot van de sum van de errors per run
min_Error <- min(alle_Errors$`Wortel sum error`)
max_Error <- max(alle_Errors$`Wortel sum error`)
barplot(alle_Errors$`Wortel sum error`, names.arg = alle_Errors$nummer, xlab = "nummer",
ylab = "Wortel van de som van de errors", main = "Error plot",
sub = paste("max error: ", max_Error, "   min error: ", min_Error, sep = " "))
#line voor min en max
abline(h = max_Error, col = "red", lwd = 3)
abline(h = min_Error, col = "green", lwd = 3)
#print van A, B en C
index_min <- which(alle_Errors$`Wortel sum error` == min_Error)
print(paste("Kleinste error bij: A:", alle_Errors$A[index_min], "B:", alle_Errors$B[index_min], "C:", alle_Errors$C[index_min]))
index_max <- which(alle_Errors$`Wortel sum error` == max_Error)
print(paste("Grootste error bij: A:", alle_Errors$A[index_max], "B:", alle_Errors$B[index_max], "C:", alle_Errors$C[index_max]))
pch.list_for_kleine_error <- as.numeric(gegevens$Given + 3)
plot(gegevens$Polarity, gegevens$Hydrophob. ,
pch=c(pch.list_for_kleine_error), xlab = "Polarity", ylab = "Hydrophob",
main = paste("Data plot voor kleinste error"),
sub = paste("A:", alle_Errors$A[index_min], "   B:", alle_Errors$B[index_min], "   C:", alle_Errors$C[index_min], "   Sum error:", alle_Errors$`Wortel sum error`[index_min], sep = " "),
xlim = c(0, 30), ylim = c(-30, 40))
x_line_plot <- c(0:28)
y_line_plot <- -c(alle_Errors$C[index_min]+alle_Errors$A[index_min] * x_line_plot)/alle_Errors$B[index_min]
lines(x_line_plot,y_line_plot)
abline(h=0,v=0)
library(plyr) #Bestand lezen ;, , ,\t
path <- file.choose() #path ophalen van file
gegevens <- ldply(path,function(x) #Gekozen bestand lezen
if(grepl(",",readLines(x,n=1))){read.csv(x,sep=",", header = TRUE, na.strings = c("", "NA"))}
else if(grepl(";",readLines(x,n=1))){read.csv(x,sep=";", header = TRUE, na.strings = c("", "NA"))}
else{read.csv(x,sep="\t", header = TRUE, na.strings = c("", "NA"))})
get_somError <- function(alle_Errors, nummer, pol, hydro, given){
#A, B en C worden random gekozen. Gebruik sample, omdat dit hele getallen geeft.
A <- sample(-50:50, 1)
B <- sample(-50:50, 1)
C <- sample(-50:50, 1)
#class predicted berekenen
Class_pred <- A * pol + B * hydro + C
#class predicted expondent
Class_pred_exp <- 1 / (1 + exp(-Class_pred))
#berekenen van error
Error <- (given - Class_pred_exp)^2
#Error en ClassPred toevoegen aan dataframe
gegevens$ClassPred <- Class_pred_exp
gegevens$Error <- Error
#Som berekenen error
sum_Error <- sum(gegevens$Error)
#Wortel berekenen van som error
wortel_sum_Error <- sqrt(sum_Error)
#Plot maken
pch.list <- as.numeric(gegevens$Given + 3)
plot(gegevens$Polarity, gegevens$Hydrophob. ,
pch=c(pch.list), xlab = "Polarity", ylab = "Hydrophob",
main = paste("Data plot: ", nummer),
sub = paste("A:", A, "   B:", B, "   C:", C, "   Sum error:", wortel_sum_Error, sep = " "),
xlim = c(0, 30), ylim = c(-30, 40))
#Lijn maken
x_line <- c(0:28)
y_line <- -c((C+A * x_line)/B)
lines(x_line,y_line)
abline(h=0,v=0)
#Alle waardes in een data.frame zetten
waardes <- c(nummer, A, B, C, wortel_sum_Error)
alle_Errors <- rbind(alle_Errors, waardes)
return(alle_Errors)
}
#De index ophalen waarin de gegevens staan die nodig zijn.
pol_index <- which(colnames(gegevens) == "Polarity")
pol <- gegevens[,pol_index]
hydro_index <- which(colnames(gegevens) == "Hydrophob.")
hydro <- gegevens[,hydro_index]
given_index <- which(colnames(gegevens) == "Given")
given <- gegevens[,given_index]
#Aanroepen van de functie hierboven.
alle_Errors <- data.frame()
nummer = 1
for(i in 1:1000){
alle_Errors <- get_somError(alle_Errors, nummer, pol, hydro, given)
nummer = nummer + 1
}
#kolomnamen maken
colnames(alle_Errors) <- c("nummer", "A", "B", "C", "Wortel sum error")
#barplot van de sum van de errors per run
min_Error <- min(alle_Errors$`Wortel sum error`)
max_Error <- max(alle_Errors$`Wortel sum error`)
barplot(alle_Errors$`Wortel sum error`, names.arg = alle_Errors$nummer, xlab = "nummer",
ylab = "Wortel van de som van de errors", main = "Error plot",
sub = paste("max error: ", max_Error, "   min error: ", min_Error, sep = " "))
#line voor min en max
abline(h = max_Error, col = "red", lwd = 3)
abline(h = min_Error, col = "green", lwd = 3)
#print van A, B en C
index_min <- which(alle_Errors$`Wortel sum error` == min_Error)
print(paste("Kleinste error bij: A:", alle_Errors$A[index_min], "B:", alle_Errors$B[index_min], "C:", alle_Errors$C[index_min]))
index_max <- which(alle_Errors$`Wortel sum error` == max_Error)
print(paste("Grootste error bij: A:", alle_Errors$A[index_max], "B:", alle_Errors$B[index_max], "C:", alle_Errors$C[index_max]))
#De plot voor de kleinste error
pch.list_for_kleine_error <- as.numeric(gegevens$Given + 3)
plot(gegevens$Polarity, gegevens$Hydrophob. ,
pch=c(pch.list_for_kleine_error), xlab = "Polarity", ylab = "Hydrophob",
main = paste("Data plot voor kleinste error"),
sub = paste("A:", alle_Errors$A[index_min], "   B:", alle_Errors$B[index_min], "   C:", alle_Errors$C[index_min], "   Sum error:", alle_Errors$`Wortel sum error`[index_min], sep = " "),
xlim = c(0, 30), ylim = c(-30, 40))
x_line_plot <- c(0:28)
y_line_plot <- -c(alle_Errors$C[index_min]+alle_Errors$A[index_min] * x_line_plot)/alle_Errors$B[index_min]
lines(x_line_plot,y_line_plot)
abline(h=0,v=0)
library(plyr) #Bestand lezen ;, , ,\t
path <- file.choose() #path ophalen van file
gegevens <- ldply(path,function(x) #Gekozen bestand lezen
if(grepl(",",readLines(x,n=1))){read.csv(x,sep=",", header = TRUE, na.strings = c("", "NA"))}
else if(grepl(";",readLines(x,n=1))){read.csv(x,sep=";", header = TRUE, na.strings = c("", "NA"))}
else{read.csv(x,sep="\t", header = TRUE, na.strings = c("", "NA"))})
get_somError <- function(alle_Errors, nummer, pol, hydro, given){
#A, B en C worden random gekozen. Gebruik sample, omdat dit hele getallen geeft.
A <- sample(-50:50, 1)
B <- sample(-50:50, 1)
C <- sample(-50:50, 1)
#class predicted berekenen
Class_pred <- A * pol + B * hydro + C
#class predicted expondent
Class_pred_exp <- 1 / (1 + exp(-Class_pred))
#berekenen van error
Error <- (given - Class_pred_exp)^2
#Error en ClassPred toevoegen aan dataframe
gegevens$ClassPred <- Class_pred_exp
gegevens$Error <- Error
#Som berekenen error
sum_Error <- sum(gegevens$Error)
#Wortel berekenen van som error
wortel_sum_Error <- sqrt(sum_Error)
#Plot maken
pch.list <- as.numeric(gegevens$Given + 3)
plot(gegevens$Polarity, gegevens$Hydrophob. ,
pch=c(pch.list), xlab = "Polarity", ylab = "Hydrophob",
main = paste("Data plot: ", nummer),
sub = paste("A:", A, "   B:", B, "   C:", C, "   Sum error:", wortel_sum_Error, sep = " "),
xlim = c(0, 30), ylim = c(-30, 40))
#Lijn maken
x_line <- c(0:28)
y_line <- -c((C+A * x_line)/B)
lines(x_line,y_line)
abline(h=0,v=0)
#Alle waardes in een data.frame zetten
waardes <- c(nummer, A, B, C, wortel_sum_Error)
alle_Errors <- rbind(alle_Errors, waardes)
return(alle_Errors)
}
#De index ophalen waarin de gegevens staan die nodig zijn.
pol_index <- which(colnames(gegevens) == "Polarity")
pol <- gegevens[,pol_index]
hydro_index <- which(colnames(gegevens) == "Hydrophob.")
hydro <- gegevens[,hydro_index]
given_index <- which(colnames(gegevens) == "Given")
given <- gegevens[,given_index]
#Aanroepen van de functie hierboven.
alle_Errors <- data.frame()
nummer = 1
for(i in 1:1000){
alle_Errors <- get_somError(alle_Errors, nummer, pol, hydro, given)
nummer = nummer + 1
}
#kolomnamen maken
colnames(alle_Errors) <- c("nummer", "A", "B", "C", "Wortel sum error")
#barplot van de sum van de errors per run
min_Error <- min(alle_Errors$`Wortel sum error`)
max_Error <- max(alle_Errors$`Wortel sum error`)
barplot(alle_Errors$`Wortel sum error`, names.arg = alle_Errors$nummer, xlab = "nummer",
ylab = "Wortel van de som van de errors", main = "Error plot",
sub = paste("max error: ", max_Error, "   min error: ", min_Error, sep = " "))
#line voor min en max
abline(h = max_Error, col = "red", lwd = 3)
abline(h = min_Error, col = "green", lwd = 3)
#print van A, B en C
index_min <- which(alle_Errors$`Wortel sum error` == min_Error)
print(paste("Kleinste error bij: A:", alle_Errors$A[index_min], "B:", alle_Errors$B[index_min], "C:", alle_Errors$C[index_min]))
index_max <- which(alle_Errors$`Wortel sum error` == max_Error)
print(paste("Grootste error bij: A:", alle_Errors$A[index_max], "B:", alle_Errors$B[index_max], "C:", alle_Errors$C[index_max]))
#De plot voor de kleinste error
pch.list_for_kleine_error <- as.numeric(gegevens$Given + 3)
plot(gegevens$Polarity, gegevens$Hydrophob. ,
pch=c(pch.list_for_kleine_error), xlab = "Polarity", ylab = "Hydrophob",
main = paste("Data plot voor kleinste error"),
sub = paste("A:", alle_Errors$A[index_min], "   B:", alle_Errors$B[index_min], "   C:", alle_Errors$C[index_min], "   Sum error:", alle_Errors$`Wortel sum error`[index_min], sep = " "),
xlim = c(0, 30), ylim = c(-30, 40))
x_line_plot <- c(0:28)
y_line_plot <- -c(alle_Errors$C[index_min]+alle_Errors$A[index_min] * x_line_plot)/alle_Errors$B[index_min]
lines(x_line_plot,y_line_plot)
abline(h=0,v=0)
